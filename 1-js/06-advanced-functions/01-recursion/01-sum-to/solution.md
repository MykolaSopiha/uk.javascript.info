Рішення з використанням циклу:

```js run
function sumTo(n) {
  let sum = 0;
  for (let i = 1; i <= n; i++) {
    sum += i;
  }
  return sum;
}

alert( sumTo(100) );
```

Рішення за допомогою рекурсії:

```js run
function sumTo(n) {
  if (n == 1) return 1;
  return n + sumTo(n - 1);
}

alert( sumTo(100) );
```

Рішення за допомогою формули: `sumTo(n) = n*(n+1)/2`:

```js run
function sumTo(n) {
  return n * (n + 1) / 2;
}

alert( sumTo(100) );
```

P.S. Звичайно, формула є найшвидшим рішенням. Вона використовує лише 3 операції для будь-якого числа `n`. Математика допомагає!

Варіант циклу є другим з точки зору швидкості. Як і у випадку рекурсії, так і в циклі, ми сумуємо ті ж числа. Але рекурсія передбачає вкладені виклики та управління стеком. Це також займає ресурси, тому це повільніше.

P.P.S. Деякі рущії підтримують оптимізацію "хвостового виклику": якщо рекурсивний відклик є останнім у функції (як в `sumTo` вище), то зовнішня функція не повинна буде відновлювати виконання, тому рущій не потребує запам’ятовувати контекст виконання. Це зменшує потребу в пам’яті, тому вважається можливим підрахунок `sumTo(100000)`. Але якщо рущій JavaScript не підтримує оптимізацію хвостового виклику (більшість з них), то буде помилка: максимальний розмір стека перевищиться, оскільки зазвичай є обмеження на загальний розмір стека.
